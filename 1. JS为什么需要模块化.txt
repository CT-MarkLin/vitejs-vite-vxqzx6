1. JS为什么需要模块化
JS诞生之初，大家将它视为网页里面的脚本，主要用于表单验证和网页特效。此时的其代码一般直接写在script元素或单个JS文件。
随着Web2.0的到来，前端工程师利用它大大提升网页的用户体验。在此期间，各种前端的库及框架被开发出来，它们最初用于兼容各个版本的浏览器，随着越来越多的用户需求被实现，JS也从简单的表单验证跃迁至应用开发级别。然而随着代码规模的膨胀，早期JS的先天缺陷暴露：没有模块。

为什么需要模块，主要是可以带来以下三种好处：
a.可维护性（每个模块都是独立的。良好设计的模块会尽量与外部的代码撇清关系，以便于独立对其进行改进和维护。维护一个独立的模块比起一团凌乱的代码来说要轻松很多。）
b.避免命名空间污染（当一些无关的代码碰巧使用到同名变量的时候，我们就会遇到“命名空间污染”的问题。这样的问题在我们开发过程中是要极力避免的。）
c.可复用性（ctrl+c & ctrl+v）

模块模式一般用来模拟类的概念,ES6之前，JS没有类的概念，于是大家就用模块来把公有和私有方法还有变量存储在一个对象中，这样我们就能在公开调用API的同时，仍然在一个闭包范围内封装私有变量和方法。
实现模块模式的方法有很多种，下面的例子是通过匿名闭包函数的方法。（在 JavaScript 中，函数是创建作用域的唯一方式。）

这种实现方式概括起来，就是使用单个全局变量来把所有的代码包含在一个函数内，由此来创建私有的命名空间和闭包作用域。显而易见的两个缺点就是：
a.作为开发者，你必须清楚地了解引入依赖文件的正确顺序。这种依赖管理工作会成为让人头疼的问题。
b.还有可能引起命名空间冲突。举个例子，要是你碰巧写了俩重名的模块怎么办？又或者你同时需要一个模块的两个版本时该怎么办？




2. 模块化规范
为了解决上述问题，社区也为JavaScript制定了一些规范


CommonJS 扩展了JavaScript 声明模块的 API.可以很方便得将某个对象导出，让他们能够被其他模块通过 require 语句来引入。通过 CommonJS，每个 JS 文件独立地存储它模块的内容（就像一个被括起来的闭包一样）。在这种作用域中，我们通过 module.exports 语句来导出对象为模块，再通过 require 语句来引入。

这种实现比起模块模式有两点好处：
a.避免全局命名空间污染
b.明确代码之间的依赖关系

CommonJS设计之初是以服务器端（NodeJS）作为使用场景，来同步载入模块，假使我们引入三个模块的话，他们会一个个地被载入。这在服务器端是可行的，因为其从硬盘直接加载，但是前端的代码加载是通过网络，两者的加载速度不在一个数量级。只要它还在读取模块，浏览器载入的页面就会一直卡着不动。


为解决上述问题，社区在CommonJS的基础上延伸出了Asynchronous Module Definition（异步模块定义规范），简称 AMD。实现异步加载模块。

这里我们使用 define 方法，第一个参数是依赖的模块，这些模块都会在后台无阻塞地加载，第二个参数则作为加载完毕的回调函数。
回调函数将会使用载入的模块作为参数。在这个例子里就是 myMoudle.最后，这些模块本身也需要通过 define 关键词来定义。

AMD 是优先浏览器的一种异步载入模块的解决方案，不支持 Node 里的一些诸如 IO，文件系统等其他服务器端的功能。另外语法上写起来也比 CommonJS 麻烦一些。


在一些同时需要 AMD 和 CommonJS 功能的项目中，你需要使用另一种规范：Universal Module Definition（通用模块定义规范）。
UMD 创造了一种同时使用两种规范的方法，并且也支持全局变量定义。所以 UMD 的模块可以同时在客户端和服务端使用。



3. 为什么需要模块打包
我们用模块化组织代码的时候，都会把模块划分在不同的文件和文件夹里，也可能会包含一些诸如 React 和 Underscore 一类的第三方库。而后，所有的这些模块都需要通过<script>标签引入到你的 HTML 文件中，然后用户在访问你网页的时候它才能正常显示和工作。每个独立的<script>标签都意味着，它们要被浏览器分别一个个地加载。
这就有可能导致页面载入时间过长。为了解决这个问题，我们就需要进行模块打包，把所有的模块合并到一个或几个文件中，以此来减少 HTTP 请求数。


4.以前常见的打包工具
如果你的代码是通过之前介绍过的模块模式来组织的，合并和压缩它们其实就只是把一些原生的 JS 代码合在一起而已。

但如果你使用的是一些浏览器原生不支持的模块系统（例如 CommonJS 或 AMD，以及 ES6 模块的支持现在也不完整），你就需要使用一些专门的构建工具来把它们转换成浏览器支持的代码。这类工具就是我们最近经常听说的 Browserify, RequireJS, Webpack 等等模块化构建、模块化加载工具了。



5. 手写打包过程
为更好的理解打包，下面带大家尝试写一个简单的打包过程。
首先得先复习一下编译的一些知识：

词法分析：将字符串分解成有意义的代码块，这些代码块被称为词法单元
语法解析：将词法单元转换成一个由元素逐级嵌套的程序语法结构树，也叫“抽象语法树”（AST）

如果有自己创建语法的需求，可以使用ANTLR





8.Vite——开发服务器优化

ESbuild是用GO编写的ES module打包工具，作者是Figma的创始人，利用Go并发编程，实现了10-100倍的效率提升。Vite用它来对项目中的依赖进行预打包，保证一个依赖最多对应一个HTTP请求，同时将CommonJS转为ES module。

利用HTTP header缓存依赖，对上述预打包过的依赖请求加上指纹及Cache-Control header，用这个指纹来判断是否应该重新加载。

优化源文件请求：源文件返回的文件带有Etag，并且本地服务器会保存每个文件的更新状态，没有变动返回304

在这一系列优化后，项目启动及后续热更新极大加快，前端开发体验极大提升。



9.Vite——生产构建
为什么生产还要打包：如像本地开发那样不打包的模式部署线上，会导致大量级联HTTP请求，不如打包部署的效率高
之所以用Rollup是因为其是一款用于ES module的打包工具，有成熟的tree sharking
虽然其打包速度确实不如ESbuild，但是：其在针对应用打包的场景更为成熟，二是生产打包的频率相比开发时低得多

